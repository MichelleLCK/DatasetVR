<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>AlphaHKU X StarmapVis | Space</title>
        <script src="packages/aframe-v1.2.0.min.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js" integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0" crossorigin="anonymous"></script>
        <script type="text/javascript" src="packages/aframe-meshline-component.min.js"></script>

        <script type="text/javascript" src="components/pointsComponent.js"></script>

        <script type="text/javascript" src="components/Compass.js"></script>
        <script type="text/javascript" src="packages/papaparse.min.js"></script>
        <script type="text/javascript" src="components/Loader.js"></script>
        <script type="text/javascript" src="globalData.js"></script>
        <script type="text/javascript" src="packages/aframe-look-at-component.min.js"></script>
        <script type="text/javascript" src="components/KeyboardControl.js"></script>
        <script type="text/javascript" src="components/Minimap.js"></script>
        <script type="text/javascript" src="packages/dat.gui.min.js"></script>
        <script type="text/javascript" src="components/ControlPanel.js"></script>
        <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        <script type="text/javascript" src="components/MovementController.js"></script>
        <script type="text/javascript" src="components/SphereIntegration.js"></script>
        <script type="text/javascript" src="components/SphereSingle.js"></script>
        <script type="text/javascript" src="components/Interactive2.js"></script>
        <script type="text/javascript" src="packages/tweenjs.min.js"></script>
        <script type="text/javascript" src="packages/js-colormaps.js"></script>
        <script type="text/javascript" src="packages/bootstrap-autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.3.0/jszip.min.js"></script>
	<script type="text/javascript" src="components/jszip-utils.js"></script>
	
    </head>

    <body>

    <div id="theSpinner" class="d-flex justify-content-center" style="height: 100%; align-items: center; background-color: #F4F6F6">
        <div class="spinner-grow m-3" style="background-color: #943126">
        </div>
        <div class="spinner-grow m-3" style="background-color: #0E6655">
        </div>
        <div class="spinner-grow m-3" style="background-color: #21618C">
        </div>
    </div>



<!-- Upload section -->

    <div class="modal modal-fullscreen" id="uploadModal" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 class="modal-title ms-2 fw-light">Upload</h4>
                </div>
                <div class="modal-body" id='uploadModalBody' style="background-color:#F4F6F6">

                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label for="formFile1" class="form-label">Please Upload Cell Data CSV File</label>
                            <input class="form-control" type="file" id="formFile1">
                        </div>
                    </div>

                    <div class="container" style="height: 15px"></div>
                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label>Please Upload Cell Image Zip File (not compulsory)</label>
                            <!-- <br/> -->
                            <input class="form-control" type="file" id="formFileZip">
                            <!-- <table class="table order-list ">
                            </table>
                            <button class="btn btn-success" type="button" id="addimg">Add Path</button> -->
                        </div>
                    </div>

                    <div class="container" style="height: 15px"></div>
                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label for="formFile2" class="form-label">Please Upload Trajectory Data CSV File (not compulsory)</label>
                            <input class="form-control" type="file" id="formFile2">
                        </div>
                    </div>

                    <div class="container" style="height: 15px"></div>
                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label>Please Specify Animation Path (not compulsory)</label><br/>
                            <table class="table order-list ">
                            </table>
                            <button class="btn btn-success" type="button" id="addrow">Add Path</button>
                        </div>
                    </div>


                    <!-- <div class="container" style="height: 15px"></div>
                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label>Please Upload Image (not compulsory)</label><br/>
                            <table class="table order-list-img">
                            </table>
                            <button class="btn btn-success" type="button" id="addrowImg">Add Image</button>
                        </div>
                    </div> -->

                    <div class="container" style="height: 15px"></div>
                    <div class="card card-body shadow">
                        <div class="mb-3">
                            <label for="formFile3" class="form-label">Please Upload Transformed Data CSV File (not compulsory)</label>
                            <input class="form-control" type="file" id="formFile3">
                        </div>
                    </div>



                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="backIndex()">Return</button>
                    <button type="button" class="btn btn-success" onclick="uploadEnter()">Enter</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade bd-example-modal-lg" id="theModal" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-scrollable" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Help</h5>
                </div>
                <div class="modal-body">
                    <p class="font-monospace"> > Manipulation: <br> 1) Use keyboard (Arrow keys and [W][A][S][D]) to change the position of the camera and the rotation of the model. <br> 2) Use mouse or gyroscope to adjust the direction of the camera, and use scroll the wheel on mouse to move forward or backward. </p>
                    <p class="font-monospace"> > Control Panel:
                        <br> 1) Switch toggles to show/hide corresponding components.
                        <br> 2) Change the marker gene by selecting from dropdown menu.
                        <br> 3) Click [Flyover] button to flyover the model by following input/default paths (corresponding input file is required).
                        <br> 4) Click [Transformation] button to transform the model (corresponding input file is required).
                    </p>
                    <p class="font-monospace"> > Interaction: <br> 1) Click red cylinders on the trajectory to move to the next checkpoint. </p>
                    <p class="font-monospace"> > Others: <br> 1) If some components/data are not visualised properly in the demo data, please reload the page. </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="$('#theModal').modal('toggle');">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade bd-example-modal-lg" id="theSearchModal" role="dialog" data-bs-keyboard="false" data-bs-backdrop="static">
        <div class="modal-dialog modal-dialog-scrollable" role="document" data-bs-keyboard="false" data-bs-backdrop="static">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Attribute Search</h5>
                </div>
                <div class="modal-body" style="height: 300px">
                    <form autocomplete="off" action="">
                        <div class="autocomplete">
                            <input id="myInput" type="text" name="myCountry" placeholder="Attribute" style="width: 100%">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" onclick="attributeSearch()">Submit</button>
                    <button type="button" class="btn btn-secondary" onclick="$('#theSearchModal').modal('toggle');
                    keyboard.enableKeyboardControl(true);">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div id="animationProgressContainer" class="progress fixed-bottom m-5" style="z-index: 1100; height: 10px; width: 75%; visibility: hidden">
        <div id="animationProgressBar" class="progress-bar bg-info" role="progressbar" style="width: 0%" aria-valuemin="0" aria-valuemax="100"></div>
    </div>

    <div class="position-fixed top-0 left-0 p-3" style="z-index: 5">
        <div id="liveToast" class="toast align-items-center text-white bg-success border-0" role="alert" aria-live="assertive" aria-atomic="true" data-delay="10000">
            <div class="d-flex">
                <div class="toast-body">
                    Animation finished.
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </div>

    <div class="position-fixed top-0 left-0 p-3" style="z-index: 5; width: 40%">
        <div id="cellImgDisplayToast" class="card" role="alert" aria-live="assertive" aria-atomic="true" data-bs-autohide="false" style="display: none">
            <div class="toast-header">
                <strong class="me-auto">Cell Image Displayer</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close" onclick="globalData.showColormap=false"></button>
            </div>
            <div class="toast-body" id="cellImgDisplayToastBody">
                <div id="selectionMode" style="float: left">Data Selection Mode:&nbsp
                    <select id="selectionModeDropdown" onchange = "selectMode()"> 
                        <option>Single</option>
                        <option>Multiple</option>
                    </select>
                </div> <br>
                <div class="slidecontainer"> Max Depth:&nbsp
                    <input type="range" min="0.005" max="200" value="200" step="2" class="slider" id="CameraDepthRange">
                    <button type="button" onclick="camera.setAttribute('far', 10000);"> Reset Depth </button>
                    <br>
                    <div id="sliderInfo" style="float: left"> Slide to adjust camera depth</div>
                </div> <br>
                <div id="selectionButtons"></div> <br>
                <div id="imgType" style="float: left">Image Type:&nbsp</div>
                <div id="imgTypeSelect"></div> <br>
                <div class="slidecontainer"> Image Scale:&nbsp
                    <input type="range" min="0.1" max="2.5" value="0.5" step="0.1" class="slider" id="imgSizeRange">
                    <br>
                    <div id="sliderInfo" style="float: left"> Slide to adjust cell image size</div>
                </div>
            </div><br>
            <div class="card-body"  id="cellImgDisplayToastBody" style="height:350px; overflow-x:hidden; overflow-y:scroll">
                <div id="imgDisplay"></div>
                <div style=" height: 22px">
                    <div id="cellId" style="float: left"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="position-fixed top-50 end-0 pe-3" style="z-index: 5; width: 300px">
        <div id="colormapToast" class="toast align-items-center border-0" role="alert" aria-live="assertive" aria-atomic="true" data-bs-autohide="false">
            <div class="toast-header">
                <strong class="me-auto">Colourmap Panel</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close" onclick="globalData.showColormap=false"></button>
            </div>

            <div class="toast-body" id="colormapToastBody">
                <img src="image/turboImg.png" class="img-fluid" id="coloPanelImg">
                <div style=" height: 22px">
                    <div id="colormapMIN" style="float: left"></div>
                    <div id="colormapMAX" style="float: right"></div>
                </div>
            </div>

            <div class="toast-body" id="colormapToastBodyCategory" style="display: none">
            </div>

        </div>
    </div>

    <div class="position-fixed top-0 left-0 p-3" style="z-index: 5">
        <div id="tipToast" class="toast align-items-center text-white bg-success border-0" role="alert" aria-live="assertive" aria-atomic="true" data-delay="10000">
            <div class="d-flex">
                <div class="toast-body">
                    TO CHANGE:
                    Use arrow keys to move around in the 3D space and [W][A][S][D] to rotate the model.
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </div>

    </body>


    <script type="text/javascript" src="components/Axis.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.161.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
			}
		}
	</script>
	    
    <script type="module">

	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { VRButton } from 'three/addons/webxr/VRButton.js';
	import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
	import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
	import { createText } from 'three/addons/webxr/Text2D.js';
	import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
	import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';
	import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';

	import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';

	class Object3D extends Component { }

	Object3D.schema = {
		object: { type: Types.Ref }
	};

	class Button extends Component { }

	Button.schema = {
		// button states: [none, hovered, pressed]
		currState: { type: Types.String, default: 'none' },
		prevState: { type: Types.String, default: 'none' },
		action: { type: Types.Ref, default: () => { } }
	};

	class ButtonSystem extends System {

		execute( /*delta, time*/ ) {

			this.queries.buttons.results.forEach( entity => {

				const button = entity.getMutableComponent( Button );
				const buttonMesh = entity.getComponent( Object3D ).object;
				if ( button.currState == 'none' ) {

					buttonMesh.scale.set( 1, 1, 1 );

				} else {

					buttonMesh.scale.set( 1.1, 1.1, 1.1 );

				}

				if ( button.currState == 'pressed' && button.prevState != 'pressed' ) {

					button.action();

				}

				// preserve prevState, clear currState
				// HandRaySystem will update currState
				button.prevState = button.currState;
				button.currState = 'none';

			} );

		}

		}

		ButtonSystem.queries = {
			buttons: {
				components: [ Button ]
			}
		};

		class Draggable extends Component { }

		Draggable.schema = {
			// draggable states: [detached, hovered, to-be-attached, attached, to-be-detached]
			state: { type: Types.String, default: 'none' },
			originalParent: { type: Types.Ref, default: null },
			attachedPointer: { type: Types.Ref, default: null }
		};

		class DraggableSystem extends System {

			execute( /*delta, time*/ ) {

				this.queries.draggable.results.forEach( entity => {

					const draggable = entity.getMutableComponent( Draggable );
					const object = entity.getComponent( Object3D ).object;
					if ( draggable.originalParent == null ) {

						draggable.originalParent = object.parent;

					}

					switch ( draggable.state ) {

						case 'to-be-attached':
							draggable.attachedPointer.children[ 0 ].attach( object );
							draggable.state = 'attached';
							break;
						case 'to-be-detached':
							draggable.originalParent.attach( object );
							draggable.state = 'detached';
							break;
						default:
							object.scale.set( 1, 1, 1 );

					}

				} );

			}

		}

		DraggableSystem.queries = {
			draggable: {
				components: [ Draggable ]
			}
		};

//	    	class Teleport extends Component { }

//	    	Teleport.schema = {
			// button states: [none, hovered, pressed]
//			currState: { type: Types.String, default: 'none' },
//			prevState: { type: Types.String, default: 'none' },
//			withCursor: { type: Types.String, default: 'none' },
//			originalParent: { type: Types.Ref, default: null },
//			attachedPointer: { type: Types.Ref, default: null }
//		};
//
//		class TeleportSystem extends System {
//
//			init( attributes ) {
//
//				this.camera = attributes.camera;
//				this.renderer = attributes.renderer;
//				this.marker = attributes.marker;
//
//			}
//
//			execute( /*delta, time*/ ) {
//
//				this.queries.teleport.results.forEach( entity => {
//
//					const teleport = entity.getMutableComponent( Teleport );
//					const room = entity.getComponent( Object3D ).object;
//
//					if ( teleport.currState != 'none' && teleport.withCursor == 'none') {		
//						let geometry, material;
//						let controller = teleport.attachedPointer.children[ 0 ];
//
//						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
//						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
//						controller.add( new THREE.Mesh( geometry, material ) );
//						teleport.withCursor = 'yes';
//	
//	
//					}
//					if ( teleport.currState == 'pressed') {
//						
//						let controller = teleport.attachedPointer.children[ 0 ];
//						let cursorMesh = controller.children[1];
//						cursorMesh.material.opacity = 0.9; 
	
//					} else if ( teleport.currState == 'hovered' && teleport.withCursor == 'yes') {
//						
//						let controller = teleport.attachedPointer.children[ 0 ];
//						let cursorMesh = controller.children[1];
//						cursorMesh.material.opacity = 0.5; 
						
//					}
	
//					if ( teleport.currState == 'pressed' && teleport.prevState != 'pressed' ) {

//						INTERSECTION = undefined;
	
//						const intersects = teleport.attachedPointer.intersectObjects( [ room ] );

//						if ( intersects.length > 0 ) {
	
//							INTERSECTION = intersects[ 0 ].point;
	
//						}

//						if ( INTERSECTION ) this.marker.position.copy( INTERSECTION );

//						this.marker.visible = INTERSECTION !== undefined;
	
//					}
	
					// preserve prevState, clear currState
					// HandRaySystem will update currState
//					teleport.prevState = teleport.currState;
//					teleport.currState = 'none';
//
//				} );

//			}

//		}

//		TeleportSystem.queries = {
//			teleport: {
//				components: [ Teleport ]
//			}
//		};

		class Intersectable extends TagComponent { }

		class HandRaySystem extends System {

			init( attributes ) {

				this.handPointers = attributes.handPointers;
				//this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/ ) {

				this.handPointers.forEach( hp => {
					let controller = hp.children[0];
					let line = controller.children[0];
					//console.log("HP Children");
					//console.log(hp.children);
					//console.log("Controller Children");
					//console.log(controller.children[0]);

					let distance = null;
					let intersectingEntity = null;
					//hp.raycaster = true;
					this.queries.intersectable.results.forEach( entity => {

						const object = entity.getComponent( Object3D ).object;
						const intersections = hp.intersectObject( object, false );
						if ( intersections && intersections.length > 0 ) {

							if ( distance == null || intersections[ 0 ].distance < distance ) {

								distance = intersections[ 0 ].distance;
								intersectingEntity = entity;

							}

						}

					} );
					
					if ( distance ) {

						hp.setCursor( distance );

						line.scale.z = distance;

						if ( intersectingEntity.hasComponent( Button ) ) {

							const button = intersectingEntity.getMutableComponent( Button );
							if ( hp.isPinched() ) {

								button.currState = 'pressed';

							} else if ( button.currState != 'pressed' ) {

								button.currState = 'hovered';

							}

						}

//						if ( intersectingEntity.hasComponent( Teleport ) ) {

//							const teleport = intersectingEntity.getMutableComponent( Teleport );

//							if ( hp.isPinched() ) {

//								teleport.currState = 'pressed';
//								teleport.attachedPointer = hp;
//								hp.setAttached( true );

//							} else if ( teleport.currState != 'pressed' ) {

//								teleport.currState = 'hovered';
//								teleport.attachedPointer = null;
//								hp.setAttached( false );

//							}

//						}

						if ( intersectingEntity.hasComponent( Draggable ) ) {

							const draggable = intersectingEntity.getMutableComponent( Draggable );
							const object = intersectingEntity.getComponent( Object3D ).object;
							object.scale.set( 1.1, 1.1, 1.1 );
							if ( hp.isPinched() ) {

								if ( ! hp.isAttached() && draggable.state != 'attached' ) {

									draggable.state = 'to-be-attached';
									draggable.attachedPointer = hp;
									hp.setAttached( true );

								}

							} else {

								if ( hp.isAttached() && draggable.state == 'attached' ) {

									console.log( 'hello' );
									draggable.state = 'to-be-detached';
									draggable.attachedPointer = null;
									hp.setAttached( false );

								}

							}

						}

					} else {

						hp.setCursor( 1.5 );
						line.scale.z = 1.5;

					}

				} );

			}

		}

		HandRaySystem.queries = {
			intersectable: {
				components: [ Intersectable ]
			}
		};

		class HandsInstructionText extends TagComponent { }

		class InstructionSystem extends System {

			init( attributes ) {

				this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/ ) {

				let visible = false;
				this.controllers.forEach( controller => {

					if ( controller.visible ) {

						visible = true;

					}

				} );

				this.queries.instructionTexts.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;
					object.visible = visible;

				} );

			}

		}

		InstructionSystem.queries = {
			instructionTexts: {
				components: [ HandsInstructionText ]
			}
		};

		class OffsetFromCamera extends Component { }

		OffsetFromCamera.schema = {
			x: { type: Types.Number, default: 0 },
			y: { type: Types.Number, default: 0 },
			z: { type: Types.Number, default: 0 },
		};

		class NeedCalibration extends TagComponent { }

		class CalibrationSystem extends System {

			init( attributes ) {

				this.camera = attributes.camera;
				this.renderer = attributes.renderer;

	}

			execute( /*delta, time*/ ) {

				this.queries.needCalibration.results.forEach( entity => {

					if ( this.renderer.xr.getSession() ) {

						const offset = entity.getComponent( OffsetFromCamera );
						const object = entity.getComponent( Object3D ).object;
						const xrCamera = this.renderer.xr.getCamera();
						object.position.x = xrCamera.position.x + offset.x;
						object.position.y = xrCamera.position.y + offset.y;
						object.position.z = xrCamera.position.z + offset.z;
						entity.removeComponent( NeedCalibration );

					}

				} );

			}

		}

		CalibrationSystem.queries = {
			needCalibration: {
				components: [ NeedCalibration ]
			}
		};

		class Randomizable extends TagComponent { }

		class RandomizerSystem extends System {

			init( /*attributes*/ ) {

				this.needRandomizing = true;

			}

			execute( /*delta, time*/ ) {

				if ( ! this.needRandomizing ) {

					return;

				}

				this.queries.randomizable.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;

					//object.material.color.setHex( Math.random() * 0xffffff );

					//object.position.x = Math.random() * 2 - 1;
					//object.position.y = Math.random() * 2;
					//object.position.z = Math.random() * 2 - 1;

					//object.rotation.x = Math.random() * 2 * Math.PI;
					//object.rotation.y = Math.random() * 2 * Math.PI;
					//object.rotation.z = Math.random() * 2 * Math.PI;

					//object.scale.x = Math.random() + 0.5;
					//object.scale.y = Math.random() + 0.5;
					//object.scale.z = Math.random() + 0.5;
					this.needRandomizing = false;
					//console.log("random ball");

				} );

			}

		}

		RandomizerSystem.queries = {
			randomizable: {
				components: [ Randomizable ]
			}
		};

	    window.EnterVRMode = function EnterVRMode () {
            console.log("ENTERED VR");

			let container;
			let camera, scene, renderer, raycaster;
			let hand1, hand2;
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;
		    	let room, marker, floor, baseReferenceSpace;
		    
		    
		    	let INTERSECTION;
		    	const world = new World();
			const clock = new THREE.Clock();

			const handModels = {
				left: null,
				right: null
			};

			let controls;

			init();
			animate();

		    	function makeButtonMesh( x, y, z, color ) {

				const geometry = new THREE.BoxGeometry( x, y, z );
				const material = new THREE.MeshPhongMaterial( { color: color } );
				const buttonMesh = new THREE.Mesh( geometry, material );
				return buttonMesh;

			}	


			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );
	
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x444444 );
	
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( 0, 0, 0 );
	
				scene.add( new THREE.HemisphereLight( 0xcccccc, 0x999999, 3 ) );
	
				//const light = new THREE.DirectionalLight( 0xffffff, 3 );
				const light = new THREE.Light( 0xffffff, 3 );
				//light.position.set( 0, 6, 0 );
				//light.castShadow = true;
				//light.shadow.camera.top = 2;
				//light.shadow.camera.bottom = - 2;
				//light.shadow.camera.right = 2;
				//light.shadow.camera.left = - 2;
				//light.shadow.mapSize.set( 4096, 4096 );
				scene.add( light );
	
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.xr.enabled = true;
				renderer.xr.cameraAutoUpdate = false;
	
				container.appendChild( renderer.domElement );
	
				document.body.appendChild( VRButton.createButton( renderer ) );
	
				// controllers

				function onSelectStart() {

					this.userData.isSelecting = true;

				}

				function onSelectEnd() {

					this.userData.isSelecting = false;

					if ( INTERSECTION ) {

						const offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };
						const offsetRotation = new THREE.Quaternion();
						const transform = new XRRigidTransform( offsetPosition, offsetRotation );
						const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace( transform );

						renderer.xr.setReferenceSpace( teleportSpaceOffset );

					}

				}

				//controller1 = renderer.xr.getController( 0 );
				//controller1.addEventListener( 'selectstart', onSelectStart );
				//controller1.addEventListener( 'selectend', onSelectEnd );
				//controller1.addEventListener( 'connected', function ( event ) {

				//	this.add( buildController( event.data ) );

				//} );
				//controller1.addEventListener( 'disconnected', function () {

				//	this.remove( this.children[ 1 ] );

				//} );
				//scene.add( controller1 );

				//controller2 = renderer.xr.getController( 1 );
				//controller2.addEventListener( 'selectstart', onSelectStart );
				//controller2.addEventListener( 'selectend', onSelectEnd );
				//controller2.addEventListener( 'connected', function ( event ) {

				//	this.add( buildController( event.data ) );

				//} );
				//controller2.addEventListener( 'disconnected', function () {

				//	this.remove( this.children[ 1 ] );

				//} );
				//scene.add( controller2 );
				
				const controller1 = renderer.xr.getController( 0 );
				scene.add( controller1 );
	
				const controller2 = renderer.xr.getController( 1 );
				scene.add( controller2 );

				const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				const line = new THREE.Line( geometry );
				line.name = 'line';
				line.scale.z = 1.5;

				//handPointer1.add( line.clone() );
				//handPointer2.add( line.clone() );

				controller1.add( line.clone() );
				controller2.add( line.clone() );
				console.log(controller1.children);
				console.log(controller2.children);
	
				const controllerModelFactory = new XRControllerModelFactory();
	
				// Hand 1
				const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );
	
				const hand1 = renderer.xr.getHand( 0 );
				hand1.add( new OculusHandModel( hand1 ) );
				const handPointer1 = new OculusHandPointerModel( hand1, controller1 );
				handPointer1.add( controller1 );
				hand1.add( handPointer1 );
	
				scene.add( hand1 );
	
				// Hand 2
				const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
	
				const hand2 = renderer.xr.getHand( 1 );
				hand2.add( new OculusHandModel( hand2 ) );
				const handPointer2 = new OculusHandPointerModel( hand2, controller2 );
				handPointer2.add( controller2 );
				hand2.add( handPointer2 );
				scene.add( hand2 );
	
	
				// setup objects in scene and entities
				//const floorGeometry = new THREE.PlaneGeometry( 10, 10 );
				//const floorMaterial = new THREE.MeshPhongMaterial( { color: 0x222222 } );
				//const floor = new THREE.Mesh( floorGeometry, floorMaterial );
				//floor.rotation.x = - Math.PI / 2;
				//floor.receiveShadow = true;
				//scene.add( floor );

				room = new THREE.LineSegments(
					new BoxLineGeometry( 10, 10, 10, 10, 10, 10 ).translate( 0, 3, 0 ),
					new THREE.LineBasicMaterial( { color: 0xbcbcbc } )
				);
				scene.add( room );

				scene.add( new THREE.HemisphereLight( 0xa5a5a5, 0x898989, 3 ) );


				marker = new THREE.Mesh(
					new THREE.CircleGeometry( 0.25, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
				);
				scene.add( marker );

				//raycaster = new THREE.Raycaster();

				//floor = new THREE.Mesh(
				//	new THREE.PlaneGeometry( 4.8, 4.8, 2, 2 ).rotateX( - Math.PI / 2 ),
				//	new THREE.MeshBasicMaterial( { color: 0xbcbcbc, transparent: true, opacity: 0.25 } )
				//);
				//scene.add( floor );

				const menuGeometry = new THREE.PlaneGeometry( 0.24, 0.5 );
				const menuMaterial = new THREE.MeshPhongMaterial( {
					opacity: 0,
					transparent: true,
				} );
				const menuMesh = new THREE.Mesh( menuGeometry, menuMaterial );
				menuMesh.position.set( 0.4, 1, - 1 );
				menuMesh.rotation.y = - Math.PI / 12;
				scene.add( menuMesh );
	
				const resetButton = makeButtonMesh( 0.2, 0.1, 0.01, 0x355c7d );
				const resetButtonText = createText( 'reset', 0.06 );
				resetButton.add( resetButtonText );
				resetButtonText.position.set( 0, 0, 0.0051 );
				resetButton.position.set( 0, - 0.06, 0 );
				menuMesh.add( resetButton );
	
				const exitButton = makeButtonMesh( 0.2, 0.1, 0.01, 0xff0000 );
				const exitButtonText = createText( 'exit', 0.06 );
				exitButton.add( exitButtonText );
				exitButtonText.position.set( 0, 0, 0.0051 );
				exitButton.position.set( 0, - 0.18, 0 );
				menuMesh.add( exitButton );
	
				const instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );
				instructionText.position.set( 0, 1.6, - 0.6 );
				scene.add( instructionText );
	
				const exitText = createText( 'Exiting session...', 0.04 );
				exitText.position.set( 0, 1.5, - 0.6 );
				exitText.visible = false;
				scene.add( exitText );
	
				world
					.registerComponent( Object3D )
					.registerComponent( Button )
					.registerComponent( Intersectable )
					.registerComponent( HandsInstructionText )
					.registerComponent( OffsetFromCamera )
					.registerComponent( NeedCalibration )
					.registerComponent( Randomizable )
					.registerComponent( Draggable )
//					.registerComponent( Teleport );
	
				world
					.registerSystem( RandomizerSystem )
					.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )
					.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )
					.registerSystem( ButtonSystem )
					.registerSystem( DraggableSystem )
//					.registerSystem( TeleportSystem, { renderer: renderer, camera: camera, marker: marker } )
					.registerSystem( HandRaySystem, { handPointers: [ handPointer1, handPointer2 ] } );
				
				let data = globalData.cellData;
				data.forEach(element => {
					let colorStr = globalData.categoricalColorDict[element[globalData.curMarkerGene.Attribute]];
					const object = new THREE.Mesh( new THREE.SphereGeometry( 0.02, 32, 16 ), new THREE.MeshLambertMaterial( { color: colorStr } ) );
					
					scene.add( object );

					if (globalData.curStatus === 1) {
					    loader.getObjectFromID(globalData.cellData3D, element[globalData.idStr], globalData.idStr).then(target => {
						object.position.x = target[globalData.curVisMethod.x]*globalData.scaleUp*0.01+1;
						object.position.y = target[globalData.curVisMethod.y]*globalData.scaleUp*0.01+1.5;
						object.position.z = target[globalData.curVisMethod.z]*globalData.scaleUp*0.01-1;
					    }, reject => {console.log(reject)})
					} else if (globalData.curStatus === 2) {
					    loader.getObjectFromID(globalData.cellData3D2, element[globalData.idStr], globalData.idStr).then(target => {
						object.position.x = target[globalData.curVisMethod.x]*globalData.scaleUp*0.01+1;
						object.position.y = target[globalData.curVisMethod.y]*globalData.scaleUp*0.01+1.5;
						object.position.z = target[globalData.curVisMethod.z]*globalData.scaleUp*0.01-1;
					    }, reject => {console.log(reject)})
					} else {
					    object.position.x = element[globalData.curVisMethod.x]*globalData.scaleUp*0.01+1;
					    object.position.y = element[globalData.curVisMethod.y]*globalData.scaleUp*0.01+1.5;
					    object.position.z = element[globalData.curVisMethod.z]*globalData.scaleUp*0.01-1;
					}
					
					//const geometry = new THREE.SphereGeometry( 15, 32, 16 ); 
					//const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
					//const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
	
					const entity = world.createEntity();
					entity.addComponent( Intersectable );
					entity.addComponent( Randomizable );
					entity.addComponent( Object3D, { object: object } );
					entity.addComponent( Draggable );
					console.log("Added a ball");
					
				    })
	
				//const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				//const line = new THREE.Line( geometry );
				//line.name = 'line';
				//controller1.add( line.clone() );
				//controller2.add( line.clone() );
				//const rayEntity = world.createEntity();
				//entity.addComponent( Intersectable );
				//entity.addComponent( Object3D, { object: line } );

	
				const menuEntity = world.createEntity();
				menuEntity.addComponent( Intersectable );
				menuEntity.addComponent( OffsetFromCamera, { x: 0.4, y: 0, z: - 1 } );
				menuEntity.addComponent( NeedCalibration );
				menuEntity.addComponent( Object3D, { object: menuMesh } );
	
				const rbEntity = world.createEntity();
				rbEntity.addComponent( Intersectable );
				rbEntity.addComponent( Object3D, { object: resetButton } );
				const rbAction = function () {
	
					world.getSystem( RandomizerSystem ).needRandomizing = true;
	
				};
	
				rbEntity.addComponent( Button, { action: rbAction } );
	
				const ebEntity = world.createEntity();
				ebEntity.addComponent( Intersectable );
				ebEntity.addComponent( Object3D, { object: exitButton } );
				const ebAction = function () {
	
					exitText.visible = true;
					setTimeout( function () {
	
						exitText.visible = false; renderer.xr.getSession().end();
	
					}, 2000 );
	
				};
	
				ebEntity.addComponent( Button, { action: ebAction } );
	
				const itEntity = world.createEntity();
				itEntity.addComponent( HandsInstructionText );
				itEntity.addComponent( Object3D, { object: instructionText } );

//				const tpEntity = world.createEntity();
//				tpEntity.addComponent( Intersectable );
//				tpEntity.addComponent( Teleport );
//				tpEntity.addComponent( Object3D, { object: room } );
				//const tpAction = function () {
	
				//	world.getSystem( TeleportSystem ).teleport = true;
	
				//};
	
				//tpEntity.addComponent( Teleport, { action: tpAction } );
	
				window.addEventListener( 'resize', onWindowResize );
	
			}

		    	//function buildController( data ) {

			//	let geometry, material;

			//	switch ( data.targetRayMode ) {

			//		case 'tracked-pointer':

			//			geometry = new THREE.BufferGeometry();
			//			geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
			//			geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

			//			material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

			//			return new THREE.Line( geometry, material );

			//		case 'gaze':

			//			geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
			//			material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
			//			return new THREE.Mesh( geometry, material );

			//	}

			//}

	
			function onWindowResize() {
	
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
	
				renderer.setSize( window.innerWidth, window.innerHeight );
	
			}
	
			function animate() {
	
				renderer.setAnimationLoop( render );
	
			}
	
			function render() {
	
				const delta = clock.getDelta();
				const elapsedTime = clock.elapsedTime;
				renderer.xr.updateCamera( camera );
				world.execute( delta, elapsedTime );

				//INTERSECTION = undefined;

				//if ( controller1.userData.isSelecting === true ) {

				//	tempMatrix.identity().extractRotation( controller1.matrixWorld );

				//	raycaster.ray.origin.setFromMatrixPosition( controller1.matrixWorld );
				//	raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				//	const intersects = raycaster.intersectObjects( [ room ] );

				//	if ( intersects.length > 0 ) {

				//		INTERSECTION = intersects[ 0 ].point;

				//	}

				//} else if ( controller2.userData.isSelecting === true ) {

				//	tempMatrix.identity().extractRotation( controller2.matrixWorld );

				//	raycaster.ray.origin.setFromMatrixPosition( controller2.matrixWorld );
				//	raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				//	const intersects = raycaster.intersectObjects( [ room ] );

				//	if ( intersects.length > 0 ) {

				//		INTERSECTION = intersects[ 0 ].point;

				//	}

				//}

				//if ( INTERSECTION ) marker.position.copy( INTERSECTION );

				//marker.visible = INTERSECTION !== undefined;
				
				renderer.render( scene, camera );
	
			}
	    }

    </script>
	
    <script>

        $('#theSearchModal').on('shown.bs.modal', function (e) {
            $(document).off('focusin.modal');
        })

        function autocomplete(inp, arr) {
            /*the autocomplete function takes two arguments,
            the text field element and an array of possible autocompleted values:*/
            var currentFocus;
            /*execute a function when someone writes in the text field:*/
            inp.addEventListener("input", function(e) {
                var a, b, i, val = this.value;
                /*close any already open lists of autocompleted values*/
                closeAllLists();
                if (!val) { return false;}
                currentFocus = -1;
                /*create a DIV element that will contain the items (values):*/
                a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                /*append the DIV element as a child of the autocomplete container:*/
                this.parentNode.appendChild(a);
                /*for each item in the array...*/
                for (i = 0; i < arr.length; i++) {
                    /*check if the item starts with the same letters as the text field value:*/
                    if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
                        /*create a DIV element for each matching element:*/
                        b = document.createElement("DIV");
                        /*make the matching letters bold:*/
                        b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
                        b.innerHTML += arr[i].substr(val.length);
                        /*insert a input field that will hold the current array item's value:*/
                        b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
                        /*execute a function when someone clicks on the item value (DIV element):*/
                        b.addEventListener("click", function(e) {
                            /*insert the value for the autocomplete text field:*/
                            inp.value = this.getElementsByTagName("input")[0].value;
                            /*close the list of autocompleted values,
                            (or any other open lists of autocompleted values:*/
                            closeAllLists();
                        });
                        a.appendChild(b);
                    }
                }
            });
            /*execute a function presses a key on the keyboard:*/
            inp.addEventListener("keydown", function(e) {
                var x = document.getElementById(this.id + "autocomplete-list");
                if (x) x = x.getElementsByTagName("div");
                if (e.keyCode == 40) {
                    /*If the arrow DOWN key is pressed,
                    increase the currentFocus variable:*/
                    currentFocus++;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 38) { //up
                    /*If the arrow UP key is pressed,
                    decrease the currentFocus variable:*/
                    currentFocus--;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 13) {
                    /*If the ENTER key is pressed, prevent the form from being submitted,*/
                    e.preventDefault();
                    if (currentFocus > -1) {
                        /*and simulate a click on the "active" item:*/
                        if (x) x[currentFocus].click();
                    }
                }
            });
            function addActive(x) {
                /*a function to classify an item as "active":*/
                if (!x) return false;
                /*start by removing the "active" class on all items:*/
                removeActive(x);
                if (currentFocus >= x.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (x.length - 1);
                /*add class "autocomplete-active":*/
                x[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(x) {
                /*a function to remove the "active" class from all autocomplete items:*/
                for (var i = 0; i < x.length; i++) {
                    x[i].classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                /*close all autocomplete lists in the document,
                except the one passed as an argument:*/
                var x = document.getElementsByClassName("autocomplete-items");
                for (var i = 0; i < x.length; i++) {
                    if (elmnt != x[i] && elmnt != inp) {
                        x[i].parentNode.removeChild(x[i]);
                    }
                }
            }
            /*execute a function when someone clicks in the document:*/
            document.addEventListener("click", function (e) {
                closeAllLists(e.target);
            });
        }
        // let countries = globalData.markerGeneList;
        // autocomplete(document.getElementById("myInput"), countries);
        autocomplete(document.getElementById("myInput"), globalData.markerGeneList);

        function attributeSearch () {
            let attribute = document.getElementById('myInput').value
            console.log('att search submit: ', attribute);
            if ( globalData.markerGeneList.includes(attribute) ) {
                globalData.curMarkerGene.Attribute = attribute;
                document.getElementById('theSpinner').style.height = '100%';
                document.getElementById('theSpinner').style.visibility = 'visible';
                setTimeout(function (){
                    if (globalData.curVisMode.Mode === 'High-Quality') {
                        loader.renderPoints(globalData.cellData, true, 1, true)
                    } else {
                        loader.renderPoints(globalData.cellData, true, 0, true)
                    }
                }, 1);
                console.log(globalData.curMarkerGene);
            } else {
                alert("Not Found!");
            }
            document.getElementById('myInput').value = "";
            $('#theSearchModal').modal('toggle');
            keyboard.enableKeyboardControl(true);
        }

        window.URL = window.URL || window.webkitURL;

        let inputPathCounter = 0;
        let inputImgCounter = 0;

        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const target = urlParams.get('target');

        let spinner, environment, sky, container, camera, cursor, axis, compass, loader, keyboard, targetObj;
        let movementController, controlPanel, loader2, minimap, uploadF1, uploadF2, uploadModal, uploadF3;

        let customImgList = [];
        let customImgCList = [];

        if (target === 'custom') {
            uploadModal = new bootstrap.Modal(document.getElementById('uploadModal'));
            uploadModal.toggle();

        } else if (target === 's1' || target === 's2' || target === 's3') {
            globalData.inputFile1 = true;
            globalData.inputZip = true;
            render2();

        }
        else {
            location.href = "index.html";
        }

        function MouseWheelHandler(e) {
            // cross-browser wheel delta
            var e = window.event || e; // old IE support

            // grab the camera
            var player = document.querySelector("a-camera")

            // get the player rotation
            var angle = player.getAttribute("rotation")
            // calculate the angles
            // the camera's theta == 0 is actually 90' in the clipspace
            let theta = (angle.x * Math.PI / 180) + Math.PI / 2
            let fi = angle.y * Math.PI / 180
            let r = 2.5
            // calculate the position shifts
            let z = Math.sin(theta) * Math.cos(fi) * r
            let x = Math.sin(theta) * Math.sin(fi) * r
            let y = Math.cos(theta) * r

            // update the position
            var pos = player.getAttribute("position")

            if (e.deltaY >= 0) {
                console.log('Move forward by wheel scroll');
                pos.x -= x;
                pos.y -= y;
                pos.z -= z;
                player.setAttribute("position", pos);

            } else {
                console.log('Move backward by wheel scroll');
                pos.x += x;
                pos.y += y;
                pos.z += z;
                player.setAttribute("position", pos);
            }
            return false;
        }

        function render2 () {

            spinner = document.getElementById('theSpinner');
            environment = document.createElement('a-entity');
            sky = document.createElement('a-sky');
            sky.setAttribute('color', '#F4F6F6');

            container = document.createElement('a-entity');
            container.setAttribute('position', '0 0 0');

            targetObj = document.createElement('a-box');
            targetObj.setAttribute('position', '0 0 0');
            targetObj.setAttribute('visible', 'false');
            targetObj.setAttribute('id', 'target');
            container.appendChild(targetObj);

            camera = document.createElement('a-camera');
            camera.setAttribute('id', 'theCamera');
            camera.setAttribute('look-controls');
            camera.setAttribute("wasd-controls", "acceleration: 270; fly: true");
            camera.setAttribute('mouse-cursor');


            if (globalData.inputSlice) {
                camera.setAttribute("position", "75 75 350");
            } else {
                if (target === 's1') {
                    camera.setAttribute("position", "30 30 250");
                } else {
                    camera.setAttribute("position", "75 75 250");
                }
            }



            cursor = document.createElement('a-entity');
            cursor.setAttribute('raycaster', "objects: [data-raycastable]");
            cursor.setAttribute('cursor', "rayOrigin:mouse");
            camera.appendChild(cursor);

            // init colormap
            fetch('packages/batlow100.txt')
                .then(response => response.text())
                .then(text => {
                    globalData.curUsingColormap = text.split("\n");
                })

            // axis = new Axis(container);
            // axis.renderAxis();

            compass = new Compass(camera, container);

            loader = new Loader(container, 'cellData');
            if (target === 'custom') {

                loader.loadCSV(uploadF1, 'cellData').then(resolve => {
                    globalData.idStr = Object.keys(resolve[0])[0];
                    globalData.cellData = resolve;
                    loader.renderPoints(resolve, false, 0, true);
                })

                if (globalData.inputFile1Trans) {
                    globalData.startFrom2D = true;
                    loader.load3DCSV(uploadF3).then(resolve => {
                        globalData.cellData3D = resolve;
                    })
                }

                if (globalData.inputZip) {
                    (loader.loadZip(uploadZip)).then(resolve => {
			console.log(uploadZip);
                        console.log(resolve);
                        globalData.cellImg = resolve["imgDict"];
                        globalData.imgTypeList = resolve["imgTypeList"];
                        globalData.curImageType = globalData.imgTypeList[0];
                        const imgTypeSelection = document.getElementById("imgTypeSelect");
                        for (let j = 0; j < globalData.imgTypeList.length; j++){
                            console.log(globalData.imgTypeList[j]);
                            const id = globalData.imgTypeList[j];

                            // create a label
                            const label = document.createElement('label');
                            label.setAttribute("for", id);
                        
                            // create a checkbox
                            const checkbox = document.createElement('input');
                            checkbox.type = "checkbox";
                            checkbox.name = id;
                            checkbox.value = id;
                            checkbox.id = id + '_checkbox';
                            checkbox.addEventListener("click", function (evt) {
                                
                                var targetElement = evt.target || evt.srcElement;
                                let index = globalData.selectedImageType.indexOf(targetElement.name);
                                console.log(targetElement.name)
                                console.log(globalData.selectedImageType)
                                console.log(index)
                                if (index != -1){
                                    console.log("unchecked")
                                    if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                        var imgBoxIdDelete = "cellImage" + globalData.selectedImageType[index];
                                        var imgBoxDelete = document.getElementById(imgBoxIdDelete);
                                        if (imgBoxDelete){
                                            imgBoxDelete.remove()
                                        }
                                        console.log(imgBoxIdDelete)
                                    } else {
                                        var imgBoxIdDelete = "cellImage" + globalData.selectedImageType[index];
                                        var imgBoxDelete = document.getElementById(imgBoxIdDelete);
                                        if (imgBoxDelete){
                                            imgBoxDelete.remove()
                                        }
                                        console.log(imgBoxIdDelete)
                                    }

                                    globalData.selectedImageType.splice(index, 1); 
                                } else {
                                    globalData.selectedImageType.push(targetElement.name);
                                    if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                        var displayRegion = document.getElementById("imgDisplay")
                                        const imgBox = document.createElement('img');
                                        imgBox.src = "image/qpiPlaceholder.png";
                                        imgBox.width = globalData.imgSize;
                                        var curImgType = targetElement.name
                                        console.log(globalData.selectedImageType)
                                        imgBox.id = "cellImage" + curImgType;
                                        displayRegion.appendChild(imgBox);
                                        console.log(curImgType)
                                    } else {
                                        var displayRegion = document.getElementById("imgDisplay")
                                        const imgBox = document.createElement('img');
                                        imgBox.src = "image/qpiPlaceholder.png";
                                        imgBox.width = globalData.imgSize;
                                        var curImgType = targetElement.name
                                        console.log(globalData.selectedImageType)
                                        imgBox.id = "cellImage" + curImgType;
                                        displayRegion.appendChild(imgBox);
                                        console.log(curImgType)
                                    }
                                    
                                }
                            });

                            // place the checkbox inside a label
                            label.appendChild(checkbox);
                            // create text node
                            label.appendChild(document.createTextNode( '\u00A0' ));
                            label.appendChild(document.createTextNode(id));
                            label.appendChild(document.createTextNode( '\u00A0\u00A0\u00A0' ));
                            // label.appendChild(document.createTextNode(" "));
                            imgTypeSelection.appendChild(label);
                            console.log(checkbox)
                        }

                        var camSlider = document.getElementById("CameraDepthRange");
                        camSlider.oninput = function() {
                            globalData.camDepth = this.value;
                            camera.setAttribute('far', this.value);
                            console.log(this.value)
                        }

                        var slider = document.getElementById("imgSizeRange");
                        // var output = document.getElementById("demo");
                        slider.oninput = function() {
                            globalData.imgScale = this.value;
                            if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                for (let m = 0; m < globalData.selectedImageType.length; m++){
                                    var selectImgType = globalData.selectedImageType[m]
                                    var curImgBox = "cellImage" + selectImgType;
                                    console.log(globalData.imgSize*globalData.imgScale)
                                    document.getElementById(curImgBox).width = globalData.imgSize*globalData.imgScale;
                                }
                            } else {
                                if(globalData.confirmSelectionBtn == false){
                                    var listImg = document.getElementById('imgDisplay').querySelectorAll('[id^="cellImage"]');
                                    for (let h = 0; h < listImg.length; h++){
                                        listImg[h].width = globalData.imgSize*globalData.imgScale;
                                    }
                                } else{
                                    var displayRegion = document.getElementById("imgDisplay")
                                    while (displayRegion.lastElementChild) {
                                        displayRegion.removeChild(displayRegion.lastElementChild);
                                    }
                                    
                                    ImgWidthTotal = globalData.imgSize*globalData.imgScale*(globalData.selectedImageType.length+1)
                                    ImgWidthTotalMax = 250
                                    if(ImgWidthTotal < ImgWidthTotalMax){
                                        for (let m = 0; m < globalData.selectedImageType.length; m++){
                                            var selectImgType = globalData.selectedImageType[m]
                                            var curImgBox = "imageContainer" + selectImgType;
                                            var iDiv = document.createElement('div');
                                            iDiv.id = curImgBox;
                                            let textNode = document.createTextNode(selectImgType + "\n");
                                            iDiv.appendChild(textNode)
                                            iDiv.appendChild(document.createElement("br"))
                                            
                                            for (let n = 0; n < globalData.curImgMultiple.length; n++){
                                                const imgBox = document.createElement('img');
                                                var curId = globalData.curImgMultiple[n];
                                                imgBox.width = globalData.imgSize;
                                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                                imgBox.width = globalData.imgSize*globalData.imgScale
                                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                                imgBox.src = curImgContent;
                                                imgBox.title = curId;
                                                iDiv.appendChild(imgBox);
                                            }
                                            displayRegion.appendChild(iDiv);
                                        }
                                    } else {
                                        for (let n = 0; n < globalData.curImgMultiple.length; n++){
                                            var curId = globalData.curImgMultiple[n];
                                            
                                            if(n == 0){
                                                var curImgBox = "imageContainer";
                                                var iDiv = document.createElement('div');
                                                iDiv.id = curImgBox;
                                                let TextImg = " ";
                                                for (let m = 0; m < globalData.selectedImageType.length; m++){
                                                    var selectImgType = globalData.selectedImageType[m]
                                                    TextImg = TextImg + selectImgType
                                                    if (m < (globalData.selectedImageType.length-1)){
                                                        TextImg = TextImg + "\u00A0\u00A0\u00A0" + "&" + "\u00A0\u00A0\u00A0"
                                                    }
                                                }
                                                TextImg = TextImg + "\n"
                                                let textNode = document.createTextNode(TextImg);
                                                iDiv.appendChild(textNode)
                                                iDiv.appendChild(document.createElement("br"))
                                            }
                                            
                                            for (let m = 0; m < globalData.selectedImageType.length; m++){
                                                const imgBox = document.createElement('img');
                                                var selectImgType = globalData.selectedImageType[m]
                                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                                imgBox.width = globalData.imgSize*globalData.imgScale
                                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                                imgBox.src = curImgContent;
                                                imgBox.title = curId;
                                                iDiv.appendChild(imgBox);
                                            }
                                        }
                                        displayRegion.appendChild(iDiv);
                                    }
                                }
                            }
                        }
                        console.log(globalData.imgTypeList);
                        
                        console.log(globalData.cellImg);
                        cellImgDisplayToast.style.display = 'block';   
                    });
                }

            } else {
                loader.loadCSV('Sample/'+ target +'/input1.csv', 'cellData').then(resolve => {
                    globalData.idStr = Object.keys(resolve[0])[0];
                    globalData.cellData = resolve;
                    loader.renderPoints(resolve, false, 0, true);
                })
                if (globalData.inputZip) {
		    uploadZip = 'Sample/'+ target +'/input1.zip';
                    (loader.loadZip_browser(uploadZip)).then(resolve => {
			console.log(uploadZip);
                        console.log(resolve);
                        globalData.cellImg = resolve["imgDict"];
                        globalData.imgTypeList = resolve["imgTypeList"];
                        globalData.curImageType = globalData.imgTypeList[0];
                        const imgTypeSelection = document.getElementById("imgTypeSelect");
                        for (let j = 0; j < globalData.imgTypeList.length; j++){
                            console.log(globalData.imgTypeList[j]);
                            const id = globalData.imgTypeList[j];

                            // create a label
                            const label = document.createElement('label');
                            label.setAttribute("for", id);
                        
                            // create a checkbox
                            const checkbox = document.createElement('input');
                            checkbox.type = "checkbox";
                            checkbox.name = id;
                            checkbox.value = id;
                            checkbox.id = id + '_checkbox';
                            checkbox.addEventListener("click", function (evt) {
                                
                                var targetElement = evt.target || evt.srcElement;
                                let index = globalData.selectedImageType.indexOf(targetElement.name);
                                console.log(targetElement.name)
                                console.log(globalData.selectedImageType)
                                console.log(index)
                                if (index != -1){
                                    console.log("unchecked")
                                    if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                        var imgBoxIdDelete = "cellImage" + globalData.selectedImageType[index];
                                        var imgBoxDelete = document.getElementById(imgBoxIdDelete);
                                        if (imgBoxDelete){
                                            imgBoxDelete.remove()
                                        }
                                        console.log(imgBoxIdDelete)
                                    } else {
                                        var imgBoxIdDelete = "cellImage" + globalData.selectedImageType[index];
                                        var imgBoxDelete = document.getElementById(imgBoxIdDelete);
                                        if (imgBoxDelete){
                                            imgBoxDelete.remove()
                                        }
                                        console.log(imgBoxIdDelete)
                                    }

                                    globalData.selectedImageType.splice(index, 1); 
                                } else {
                                    globalData.selectedImageType.push(targetElement.name);
                                    if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                        var displayRegion = document.getElementById("imgDisplay")
                                        const imgBox = document.createElement('img');
                                        imgBox.src = "image/qpiPlaceholder.png";
                                        imgBox.width = globalData.imgSize;
                                        var curImgType = targetElement.name
                                        console.log(globalData.selectedImageType)
                                        imgBox.id = "cellImage" + curImgType;
                                        displayRegion.appendChild(imgBox);
                                        console.log(curImgType)
                                    } else {
                                        var displayRegion = document.getElementById("imgDisplay")
                                        const imgBox = document.createElement('img');
                                        imgBox.src = "image/qpiPlaceholder.png";
                                        imgBox.width = globalData.imgSize;
                                        var curImgType = targetElement.name
                                        console.log(globalData.selectedImageType)
                                        imgBox.id = "cellImage" + curImgType;
                                        displayRegion.appendChild(imgBox);
                                        console.log(curImgType)
                                    }
                                    
                                }
                            });

                            // place the checkbox inside a label
                            label.appendChild(checkbox);
                            // create text node
                            label.appendChild(document.createTextNode( '\u00A0' ));
                            label.appendChild(document.createTextNode(id));
                            label.appendChild(document.createTextNode( '\u00A0\u00A0\u00A0' ));
                            // label.appendChild(document.createTextNode(" "));
                            imgTypeSelection.appendChild(label);
                            console.log(checkbox)
                        }

                        var camSlider = document.getElementById("CameraDepthRange");
                        camSlider.oninput = function() {
                            globalData.camDepth = this.value;
                            camera.setAttribute('far', this.value);
                            console.log(this.value)
                        }

                        var slider = document.getElementById("imgSizeRange");
                        // var output = document.getElementById("demo");
                        slider.oninput = function() {
                            globalData.imgScale = this.value;
                            if (document.getElementById("selectionModeDropdown").value == 'Single'){
                                for (let m = 0; m < globalData.selectedImageType.length; m++){
                                    var selectImgType = globalData.selectedImageType[m]
                                    var curImgBox = "cellImage" + selectImgType;
                                    console.log(globalData.imgSize*globalData.imgScale)
                                    document.getElementById(curImgBox).width = globalData.imgSize*globalData.imgScale;
                                }
                            } else {
                                if(globalData.confirmSelectionBtn == false){
                                    var listImg = document.getElementById('imgDisplay').querySelectorAll('[id^="cellImage"]');
                                    for (let h = 0; h < listImg.length; h++){
                                        listImg[h].width = globalData.imgSize*globalData.imgScale;
                                    }
                                } else{
                                    var displayRegion = document.getElementById("imgDisplay")
                                    while (displayRegion.lastElementChild) {
                                        displayRegion.removeChild(displayRegion.lastElementChild);
                                    }
                                    
                                    ImgWidthTotal = globalData.imgSize*globalData.imgScale*(globalData.selectedImageType.length+1)
                                    ImgWidthTotalMax = 250
                                    if(ImgWidthTotal < ImgWidthTotalMax){
                                        for (let m = 0; m < globalData.selectedImageType.length; m++){
                                            var selectImgType = globalData.selectedImageType[m]
                                            var curImgBox = "imageContainer" + selectImgType;
                                            var iDiv = document.createElement('div');
                                            iDiv.id = curImgBox;
                                            let textNode = document.createTextNode(selectImgType + "\n");
                                            iDiv.appendChild(textNode)
                                            iDiv.appendChild(document.createElement("br"))
                                            
                                            for (let n = 0; n < globalData.curImgMultiple.length; n++){
                                                const imgBox = document.createElement('img');
                                                var curId = globalData.curImgMultiple[n];
                                                imgBox.width = globalData.imgSize;
                                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                                imgBox.width = globalData.imgSize*globalData.imgScale
                                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                                imgBox.src = curImgContent;
                                                imgBox.title = curId;
                                                iDiv.appendChild(imgBox);
                                            }
                                            displayRegion.appendChild(iDiv);
                                        }
                                    } else {
                                        for (let n = 0; n < globalData.curImgMultiple.length; n++){
                                            var curId = globalData.curImgMultiple[n];
                                            
                                            if(n == 0){
                                                var curImgBox = "imageContainer";
                                                var iDiv = document.createElement('div');
                                                iDiv.id = curImgBox;
                                                let TextImg = " ";
                                                for (let m = 0; m < globalData.selectedImageType.length; m++){
                                                    var selectImgType = globalData.selectedImageType[m]
                                                    TextImg = TextImg + selectImgType
                                                    if (m < (globalData.selectedImageType.length-1)){
                                                        TextImg = TextImg + "\u00A0\u00A0\u00A0" + "&" + "\u00A0\u00A0\u00A0"
                                                    }
                                                }
                                                TextImg = TextImg + "\n"
                                                let textNode = document.createTextNode(TextImg);
                                                iDiv.appendChild(textNode)
                                                iDiv.appendChild(document.createElement("br"))
                                            }
                                            
                                            for (let m = 0; m < globalData.selectedImageType.length; m++){
                                                const imgBox = document.createElement('img');
                                                var selectImgType = globalData.selectedImageType[m]
                                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                                imgBox.width = globalData.imgSize*globalData.imgScale
                                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                                imgBox.src = curImgContent;
                                                imgBox.title = curId;
                                                iDiv.appendChild(imgBox);
                                            }
                                        }
                                        displayRegion.appendChild(iDiv);
                                    }
                                }
                            }
                        }
                        console.log(globalData.imgTypeList);
                        
                        console.log(globalData.cellImg);
                        cellImgDisplayToast.style.display = 'block';   
                    });
                }
            }

            keyboard = new KeyboardControl(container);
            keyboard.init();

            // TODO here is a bug
            keyboard.enableKeyboardControl(true);

            movementController = new MovementController();

            if (globalData.inputSlice) {
                if (target !== 'custom') {
                    loadSlice(container, target);
                }

            }

            setTimeout(function (){
                // load the second csv file
                loader2 = new Loader(container, 'trajectory');
                loader2.registerComp();

                let loader2Para;

                if (target === 'custom') {
                    loader2Para = uploadF2;
                } else {
                    if (globalData.inputFile2) {
                        loader2Para = 'Sample/'+ target +'/input2.csv';
                    }
                }


                loader2.loadCSV(loader2Para, 'trajectory').then(function (resolve){
                    if (resolve) {
                        globalData.trajectoryData = resolve;
                        loader2.renderTrajectory(resolve);
                    }

                    // load the minimap
                    if (globalData.inputFile2 && target !== 's3' && target !== 's4') {
                        minimap = new Minimap(camera);
                        minimap.renderMinimap();
                    }

                    // show the colormapInfo
                    $('#colormapToast').toast('show');
                })


                let scene = document.createElement('a-scene');
                scene.setAttribute('id', "scene");
                scene.appendChild(environment);
                scene.appendChild(container);

                // let cameraWrapper = document.createElement('a-box');
                // let lookAtPos = new THREE.Vector3(0,0,0);
                // cameraWrapper.appendChild(camera);
                // cameraWrapper.setAttribute('look-at', lookAtPos);
                // console.log(cameraWrapper);
                scene.appendChild(camera);

                //scene.setAttribute('vr-mode-ui', 'enabled', false);

                // add wheel scroll function
                if (scene.addEventListener) {
                    // IE9, Chrome, Safari, Opera
                    scene.addEventListener("mousewheel", MouseWheelHandler, false);
                    // Firefox
                    scene.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
                }
                // IE 6/7/8
                else scene.attachEvent("onmousewheel", MouseWheelHandler);

                let assets = document.createElement('a-assets');
                scene.appendChild(assets);

                for (let i = 0; i < customImgList.length; i++) {

                    let tempSrc = window.URL.createObjectURL(customImgList[i]);
                    let imgO = document.createElement('img');
                    imgO.id = 'theImgID'+(i+1);
                    imgO.src = tempSrc;
                    imgO.crossOrigin = 'crossorigin';
                    assets.appendChild(imgO);

                    let img = document.createElement("a-image");
                    img.setAttribute('src', '#theImgID'+(i+1));
                    img.setAttribute('id', 'slice'+(i+1));
                    img.setAttribute('height', '150');
                    img.setAttribute('width', '150');

                    img.setAttribute('position', '75, 75, '+(customImgCList[i] * globalData.scaleUp - 5));
                    img.setAttribute('rotation', '0 0 0');

                    container.appendChild(img);

                    img.onload = function () {
                        window.URL.revokeObjectURL(tempSrc);
                    }
                }

                document.querySelector('body').appendChild(scene);
		EnterVRMode();
		    
		//if (scene.hasLoaded) {
		//  EnterVRMode();
		//} else {
		//  scene.addEventListener('enter-vr', EnterVRMode);
		//}

                $(document).ready(function() {

                    // todo
                    if (target === 'custom' || target === 's1' || target === 's2' || target === 's3'){
                        loader.renderPoints(globalData.cellData, true, 0, true);
                    }

                    if (globalData.inputFile1Trans && globalData.cellData3D !== null) {
                        loader.uniteObjects(globalData.cellData3D, globalData.cellData, globalData.curMarkerGene.Attribute)
                        if (globalData.inputFile1Trans2 && globalData.cellData3D2 !== null) {
                            loader.uniteObjects(globalData.cellData3D2, globalData.cellData, globalData.curMarkerGene.Attribute)
                        }
                    }

                    if (target === 's4') {
                        container.setAttribute('rotation', "0 -45 0");
                    }

                    document.getElementById('trajectory').setAttribute('visible', ''+globalData.showTrajectory);

                    spinner.style.visibility = "hidden";
                    // load the control panel
                    controlPanel = new ControlPanel();
                    controlPanel.init();

                    $('#tipToast').toast('show');
                });
            }, 500);
        }

        function loadSlice(container, id) {
            if (id === 's4') {
                let slice1 = document.createElement('a-image');
                slice1.setAttribute('id', 'slice1');
                slice1.setAttribute('src', 'Sample/'+id+'/1.png');
                slice1.setAttribute('height', '120');
                slice1.setAttribute('width', '120');
                slice1.setAttribute('position', '115, 0, -5');
                slice1.setAttribute('rotation', '0 0 0');
                container.appendChild(slice1);

                let slice2 = document.createElement('a-image');
                slice2.setAttribute('id', 'slice2');
                slice2.setAttribute('src', 'Sample/'+id+'/2.png');
                slice2.setAttribute('height', '120');
                slice2.setAttribute('width', '120');
                slice2.setAttribute('position', '0, 0, -5');
                slice2.setAttribute('rotation', '0 0 0');
                container.appendChild(slice2);

                let slice3 = document.createElement('a-image');
                slice3.setAttribute('id', 'slice3');
                slice3.setAttribute('src', 'Sample/'+id+'/3.png');
                slice3.setAttribute('height', '120');
                slice3.setAttribute('width', '120');
                slice3.setAttribute('position', '115, 115, -5');
                slice3.setAttribute('rotation', '0 0 0');
                container.appendChild(slice3);

                let slice4 = document.createElement('a-image');
                slice4.setAttribute('id', 'slice4');
                slice4.setAttribute('src', 'Sample/'+id+'/4.png');
                slice4.setAttribute('height', '120');
                slice4.setAttribute('width', '120');
                slice4.setAttribute('position', '0, 115, -5');
                slice4.setAttribute('rotation', '0 0 0');
                container.appendChild(slice4);
            }
        }





        function uploadEnter() {

            customImgList = [];
            customImgCList = [];

            uploadF1 = document.getElementById('formFile1').files[0];
            uploadF2 = document.getElementById('formFile2').files[0];
            uploadF3 = document.getElementById('formFile3').files[0];
            uploadZip = document.getElementById('formFileZip').files[0];

            let inputPath = {}
            for (let i = 0; i < inputPathCounter; i++) {
                let key = document.getElementById('inputPathName'+i).value;
                let value = document.getElementById('inputPath'+i).value;
                if (key !== '' && value !== ''){
                    inputPath[key] = value;
                }
            }

            for (let i = 0; i < inputImgCounter; i++) {
                let img = document.getElementById('inputImg'+i).files[0];
                let imgC = document.getElementById('inputImgC'+i).value;
                if (img && imgC !== '') {
                    if (img.type === 'image/png') {
                        customImgList.push(img);
                        customImgCList.push(parseInt(imgC));
                        globalData.numOfSlices = globalData.numOfSlices + 1;
                    }
                }
            }

            if (uploadF1 !== undefined) {
                globalData.inputFile1 = true;
                if (uploadF2 !== undefined) {
                    globalData.inputFile2 = true;
                    if (inputPathCounter > 0 && Object.keys(inputPath).length > 0) {
                        globalData.curAnimationPath = inputPath;
                        globalData.inputPath = true;
                    }
                }

                if (uploadF3 !== undefined) {
                    globalData.inputFile1Trans = true;
                    globalData.startFrom2D = true;
                }

                if (customImgList.length > 0) {
                    globalData.inputSlice = true;
                }

                if (uploadZip !== undefined) {
                    globalData.inputZip = true;
                }

                render2();
                uploadModal.toggle();

            } else {

                alert('No data received');

            }

        }

        function backIndex() {
            location.href = "index.html";
        }

        function closeTip() {
            console.log('Close button is pressed');
        }

        function selectMode() {
            const optionBox = document.getElementById("selectionButtons");
            const selectionModeDropdown = document.getElementById("selectionModeDropdown");
            const displayRegion = document.getElementById("imgDisplay");
            globalData.curSelectionMode = selectionModeDropdown.value;
            if (globalData.curSelectionMode == "Multiple"){
                // clear html contents from Single Selection Mode
                while (displayRegion.lastElementChild) {
                        displayRegion.removeChild(displayRegion.lastElementChild);
                }
                var allCheckboxes = document.querySelectorAll('input[id$="_checkbox"]');
                for (let p = 0; p < allCheckboxes.length; p++){
                    allCheckboxes[p].checked = false;
                }
                globalData.selectedImageType= [];
                document.getElementById('cellId').innerText = "";


                var startSelectionBtn = document.createElement("button")
                var confirmSelectionBtn = document.createElement("button")
                var removeSelectionBtn = document.createElement("button")
                var exportSelectionBtn = document.createElement("button")
                var resetSelectionBtn = document.createElement("button")
                
                globalData.confirmSelectionBtn = false;


                startSelectionBtn.innerHTML= "Start Data Selection";
                startSelectionBtn.addEventListener("click", function() {
                    globalData.startSelectionBtn = true
                    startSelectionBtn.innerHTML = "Selecting..."
                    globalData.removeSelectionBtn = false;
                    removeSelectionBtn.innerHTML = "Remove Selection"
                    globalData.confirmSelectionBtn = false;
                    
                    var displayRegion = document.getElementById("imgDisplay")
                    while (displayRegion.lastElementChild) {
                        displayRegion.removeChild(displayRegion.lastElementChild);
                    }
                    for (let m = 0; m < globalData.selectedImageType.length; m++){
                        const imgBox = document.createElement('img');
                        imgBox.src = "image/qpiPlaceholder.png";
                        imgBox.width = globalData.imgSize*globalData.imgScale
                        var curImgType = globalData.selectedImageType[m]
                        console.log(globalData.selectedImageType)
                        imgBox.id = "cellImage" + curImgType;
                        displayRegion.appendChild(imgBox);
                        console.log(curImgType)
                    }
                    
                });
                optionBox.appendChild(startSelectionBtn);

                
                confirmSelectionBtn.innerHTML= "Confirm Data Selection";
                confirmSelectionBtn.addEventListener("click", function() {
                    globalData.startSelectionBtn = false
                    startSelectionBtn.innerHTML = "Start/Resume Data Selection"
                    globalData.removeSelectionBtn = false;
                    removeSelectionBtn.innerHTML = "Remove Selection"
                    globalData.confirmSelectionBtn = true;
                    // clear Image Display Region
                    while (displayRegion.lastElementChild) {
                        displayRegion.removeChild(displayRegion.lastElementChild);
                    }
                    
                    ImgWidthTotal = globalData.imgSize*globalData.imgScale*(globalData.selectedImageType.length+1)
                    ImgWidthTotalMax = 250
                    if(ImgWidthTotal < ImgWidthTotalMax){
                        for (let m = 0; m < globalData.selectedImageType.length; m++){
                            var selectImgType = globalData.selectedImageType[m]
                            var curImgBox = "imageContainer" + selectImgType;
                            var iDiv = document.createElement('div');
                            iDiv.id = curImgBox;
                            let textNode = document.createTextNode(selectImgType + "\n");
                            iDiv.appendChild(textNode)
                            iDiv.appendChild(document.createElement("br"))
                            
                            for (let n = 0; n < globalData.curImgMultiple.length; n++){
                                const imgBox = document.createElement('img');
                                var curId = globalData.curImgMultiple[n];
                                imgBox.width = globalData.imgSize;
                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                imgBox.width = globalData.imgSize*globalData.imgScale
                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                imgBox.src = curImgContent;
                                imgBox.title = curId;
                                iDiv.appendChild(imgBox);
                            }
                            displayRegion.appendChild(iDiv);
                        }
                    } else {
                        for (let n = 0; n < globalData.curImgMultiple.length; n++){
                            var curId = globalData.curImgMultiple[n];
                            
                            if(n == 0){
                                var curImgBox = "imageContainer";
                                var iDiv = document.createElement('div');
                                iDiv.id = curImgBox;
                                let TextImg = " ";
                                for (let m = 0; m < globalData.selectedImageType.length; m++){
                                    var selectImgType = globalData.selectedImageType[m]
                                    TextImg = TextImg + selectImgType
                                    if (m < (globalData.selectedImageType.length-1)){
                                        TextImg = TextImg + "\u00A0\u00A0\u00A0" + "&" + "\u00A0\u00A0\u00A0"
                                    }
                                }
                                TextImg = TextImg + "\n"
                                let textNode = document.createTextNode(TextImg);
                                iDiv.appendChild(textNode)
                                iDiv.appendChild(document.createElement("br"))
                            }
                            
                            for (let m = 0; m < globalData.selectedImageType.length; m++){
                                const imgBox = document.createElement('img');
                                var selectImgType = globalData.selectedImageType[m]
                                imgBox.id = "cellImage" + selectImgType+'_'+curId;
                                imgBox.width = globalData.imgSize*globalData.imgScale
                                var curImgContent = globalData.cellImg[selectImgType][curId];
                                imgBox.src = curImgContent;
                                imgBox.title = curId;
                                iDiv.appendChild(imgBox);
                            }
                        }
                        displayRegion.appendChild(iDiv);
                    }
                });
                optionBox.appendChild(confirmSelectionBtn);

                
                removeSelectionBtn.innerHTML = "Remove Selection"
                removeSelectionBtn.addEventListener("click", function() {
                    globalData.startSelectionBtn = false
                    startSelectionBtn.innerHTML = "Start/Resume Data Selection"
                    globalData.removeSelectionBtn = true
                    removeSelectionBtn.innerHTML = "Removing..."
                    globalData.confirmSelectionBtn = false;
                    
                    var displayRegion = document.getElementById("imgDisplay")
                    while (displayRegion.lastElementChild) {
                        displayRegion.removeChild(displayRegion.lastElementChild);
                    }
                    
                    for (let m = 0; m < globalData.selectedImageType.length; m++){
                        const imgBox = document.createElement('img');
                        imgBox.src = "image/qpiPlaceholder.png";
                        imgBox.width = globalData.imgSize*globalData.imgScale
                        var curImgType = globalData.selectedImageType[m]
                        console.log(globalData.selectedImageType)
                        imgBox.id = "cellImage" + curImgType;
                        displayRegion.appendChild(imgBox);
                        console.log(curImgType)
                    }
                    
                });
                optionBox.appendChild(removeSelectionBtn);


                exportSelectionBtn.innerHTML= "Export Selection";
                exportSelectionBtn.addEventListener("click", function() {
                    globalData.exportSelectionBtn = true
                    globalData.confirmSelectionBtn = false;
                    
                    const titleKeys = Object.values(["Cell Image"])
                    const refinedData = []
                    refinedData.push(titleKeys)
                    
                    for (let n = 0; n < globalData.curImgMultiple.length; n++){
                        refinedData.push(Object.values([globalData.curImgMultiple[n]]))
                    }
                    
                    let csvContent = ''

                    refinedData.forEach(row => {
                      csvContent += row.join(',') + '\n'
                    })
                    
                    console.log(refinedData)
                    const blob = new Blob([csvContent], { type: 'text/csv' })
                    const objUrl = URL.createObjectURL(blob)
                    const link = document.createElement('a')
                    link.setAttribute('href', objUrl)
                    link.setAttribute('download', 'SelectedCellID.csv')
                    console.log(csvContent)
                    document.body.appendChild(link)
                    link.click();
                    
                    
                });
                optionBox.appendChild(exportSelectionBtn);

            
                resetSelectionBtn.innerHTML= "Reset Selection";
                resetSelectionBtn.addEventListener("click", function() {
                    globalData.resetSelectionBtn = true
                    globalData.confirmSelectionBtn = false;
                    var elementsSphere = document.querySelectorAll('a-sphere');
                    for (let h = 0; h < elementsSphere.length; h++){
                        elementsSphere[h].setAttribute('material', 'opacity', '1')
                    }
                    globalData.curImgMultiple = []
                    
                    var displayRegion = document.getElementById("imgDisplay")
                    while (displayRegion.lastElementChild) {
                        displayRegion.removeChild(displayRegion.lastElementChild);
                    }
                    
                    for (let m = 0; m < globalData.selectedImageType.length; m++){
                        const imgBox = document.createElement('img');
                        imgBox.src = "image/qpiPlaceholder.png";
                        imgBox.width = globalData.imgSize*globalData.imgScale
                        var curImgType = globalData.selectedImageType[m]
                        console.log(globalData.selectedImageType)
                        imgBox.id = "cellImage" + curImgType;
                        displayRegion.appendChild(imgBox);
                        console.log(curImgType)
                    }
                    
                });
                optionBox.appendChild(resetSelectionBtn);
            } else {
                // clear html contents from Multiple Selection Mode
                while (optionBox.lastElementChild) {
                    optionBox.removeChild(optionBox.lastElementChild);
                }
                while (displayRegion.lastElementChild) {
                    displayRegion.removeChild(displayRegion.lastElementChild);
                }
                var allCheckboxes = document.querySelectorAll('input[id$="_checkbox"]');
                for (let p = 0; p < allCheckboxes.length; p++){
                    allCheckboxes[p].checked = false;
                }
                globalData.selectedImageType= [];
                
            }
        }

        $(document).ready(function () {

            $("#addrow").on("click", function () {
                var newRow = $("<tr class='row ps-2 pt-2'>");
                var cols = "";

                cols += '<td class="col-3" style="padding: 0">' +
                    '<input type="text" class="form-control" name="name' + inputPathCounter + '" placeholder="Path name" id="inputPathName' + inputPathCounter + '"/>' +
                    '</td>';
                cols += '<td class="col-8" style="padding: 0">' +
                    '<input type="text" class="form-control" name="path' + inputPathCounter + '" placeholder="Checkpoints" id="inputPath' + inputPathCounter + '"/>' +
                    '</td>';

                cols += '<td class="col-1" style="padding: 0"><input type="button" class="ibtnDel btn btn-primary"  value="Delete"></td>';

                newRow.append(cols);
                $("table.order-list").append(newRow);
                inputPathCounter++;
            });
            $("table.order-list").on("click", ".ibtnDel", function (event) {
                $(this).closest("tr").remove();
                inputPathCounter -= 1
                console.log(inputPathCounter, ' path left');
            });


            $("#addrowImg").on("click", function () {
                var newRow = $("<tr class='row ps-2 pt-2'>");
                var cols = "";

                cols += '<td class="col-8" style="padding: 0">' +
                    '<input class="form-control" type="file" id="inputImg' + inputImgCounter + '">' +
                    '</td>';
                cols += '<td class="col-3" style="padding: 0">' +
                    '<input type="text" class="form-control" name="path' + inputImgCounter + '" placeholder="Coordinate on Z-axis" id="inputImgC' + inputImgCounter + '"/>' +
                    '</td>';

                cols += '<td class="col-1" style="padding: 0"><input type="button" class="ibtnDel btn btn-primary"  value="Delete"></td>';

                newRow.append(cols);
                $("table.order-list-img").append(newRow);
                inputImgCounter++;
            });
            $("table.order-list-img").on("click", ".ibtnDel", function (event) {
                $(this).closest("tr").remove();
                inputImgCounter -= 1;
                console.log(inputImgCounter, ' img left');
            });

        });
	
	
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        .btn-primary {
            background-color: #154360 !important;
            border-color: #154360;
        }

        .btn-success {
            background-color: #16A085;
            border-color: #16A085;
        }

        .btn:hover,
        .btn:active,
        .btn:focus,
        .btn:visited{
            background-color: #EB984E !important;
            border-color: #EB984E !important;
        }

        input[type="text"] {
            box-sizing: border-box;
        }

        /*.autocomplete {*/
        /*    !*the container must be positioned relative:*!*/
        /*    position: relative;*/
        /*    display: inline-block;*/
        /*}*/
        /*input {*/
        /*    border: 1px solid transparent;*/
        /*    background-color: #f1f1f1;*/
        /*    padding: 10px;*/
        /*    font-size: 16px;*/
        /*}*/
        /*input[type=text] {*/
        /*    background-color: #f1f1f1;*/
        /*    width: 100%;*/
        /*}*/
        /*input[type=submit] {*/
        /*    background-color: DodgerBlue;*/
        /*    color: #fff;*/
        /*}*/
        /*.autocomplete-items {*/
        /*    position: absolute;*/
        /*    border: 1px solid #d4d4d4;*/
        /*    border-bottom: none;*/
        /*    border-top: none;*/
        /*    z-index: 99;*/
        /*    !*position the autocomplete items to be the same width as the container:*!*/
        /*    top: 100%;*/
        /*    left: 0;*/
        /*    right: 0;*/
        /*}*/
        /*.autocomplete-items div {*/
        /*    padding: 10px;*/
        /*    cursor: pointer;*/
        /*    background-color: #fff;*/
        /*    border-bottom: 1px solid #d4d4d4;*/
        /*}*/
        /*.autocomplete-items div:hover {*/
        /*    !*when hovering an item:*!*/
        /*    background-color: #e9e9e9;*/
        /*}*/
        /*.autocomplete-active {*/
        /*    !*when navigating through the items using the arrow keys:*!*/
        /*    background-color: DodgerBlue !important;*/
        /*    color: #ffffff;*/
        /*}*/


    </style>
</html>
